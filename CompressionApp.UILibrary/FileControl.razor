@inject IFileCompressService FileCompresser
@inject IFileDecompressService FileDecompresser

@if (!string.IsNullOrWhiteSpace(_errorMessage))
{
	<div class="error-container">
		<h1 class="error-title">Error:</h1>
		<p>@_errorMessage</p>
	</div>
}

@if (FilesPicked.Count() > 0)
{
	<ul class="file-card-list">
		@foreach (var file in FilesPicked)
		{
			<li class="file-card">
				<span>@file.SourceFilename</span>
				<button class="remove-btn" @onclick="() => RemoveFile(file)">X</button>
			</li>
		}
	</ul>
}

<div class="file-upload-section">
	<label for="file-upload" class="custom-file-upload">
		Upload Files
	</label>
	<InputFile OnChange="@LoadFiles" id="file-upload" accept="*.*" multiple />
</div>

<div class="action-buttons">
	<button class="compress-button" @onclick="CompressFileAsync">Compress</button>
	<button class="decompress-button" @onclick="DecompressFileAsync">Decompress</button>
</div>


@code {
	private List<FileSourceModel> FilesPicked { get; set; }
	private FileDestinationModel FileDestination { get; set; }
	private CancellationTokenSource? _cts;
	private string _errorMessage = string.Empty;

	protected override async Task OnInitializedAsync()
	{
		FilesPicked ??= new();
		FileDestination ??= new();
	}


	private void LoadFiles(InputFileChangeEventArgs e)
	{
		var filesSelected = e.GetMultipleFiles();
		FileValidator validator = new();
		var validation = validator.ValidateFiles(
			filesSelected.Select(f => (f.Name, f.Size)).ToArray()
		);

		if (!validation.result)
		{
			FilesPicked = new();
			_errorMessage = validation.errorMessage;
			return;
		}

		_errorMessage = string.Empty;

		FilesPicked = e.GetMultipleFiles().Select(f => new FileSourceModel
			{
				SourceFilename = f.Name,
				SourceStream = f.OpenReadStream()
			}).ToList();
	}

	private async Task CompressFileAsync()
	{
		_cts?.Cancel();
		_cts = new CancellationTokenSource();


		if (FilesPicked.Count() > 0)
		{
			FileDestination.DestinationFilename = await FileCompresser.CompressFiles(
				FilesPicked.Select(f => (f.SourceFilename, f.SourceStream)),
				_cts.Token);
		}
	}

	private async Task DecompressFileAsync()
	{
		_cts?.Cancel();
		_cts = new CancellationTokenSource();

		if (FilesPicked.Count() > 0)
		{
			FileDestination.DestinationFolder = await FileDecompresser.DecompressFiles(
				FilesPicked.Select(f => (f.SourceFilename, f.SourceStream)),
				_cts.Token);
		}
	}

	private void RemoveFile(FileSourceModel file)
	{
		FilesPicked.Remove(file);
	}
}
